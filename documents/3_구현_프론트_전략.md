# Frontend Tech Architecture Summary

## 프로젝트 개요
- 본 프로젝트는 어드민 스타일 SPA 프론트엔드 셸을 기반으로 한 탭 기반 UI 구조입니다.
- 좌측 GNB + 상단 Header + 탭 네비게이션 + 컨텐츠 영역 + Footer 구조로 설계되었습니다
- 여러 페이지를 크롬 브라우저 스타일의 탭으로 열고 상태를 유지하는 것을 목표로 합니다.

## 기술 스택

### Core
```
React 19
TypeScript
Vite
React Router v7
```

## 프론트엔드 개발

### 상세 가이드라인

#### 아키텍처 규칙: "All-in-One Hook"
  - Hook 중심 설계: use[Domain]Dashboard.ts 파일 하나에 Interface, Fetch 로직을 모두 포함한다. (클래스,파일 분리 지양)
  - 여러 Hook 에서 반복적으로 사용되는 Interface의 경우에는 공통의 파일에서 선언하고 참조하여 사용해야 한다
  - 반복사용 Interface 공통처리 예시 : `{도메인 명}Types.ts` 파일에 공통인터페이스를 선언하고 다른 파일에서 참조하여 사용
  ```
    ├── pages
    │   ├── library
    │   │   ├── admin
    │   │   │   ├── AdminLoanHistoryPage.tsx
    │   │   │   ├── AdminReservationPage.tsx
    │   │   │   ├── useAdminLoanHistory.ts
    │   │   │   ├── useAdminReservation.ts
    │   │   ├── libraryTypes.ts  // ⭐️ 여기에 공통 인터페이스를 정의
    │   │   └── user
    │   │       ├── MyLoanHistoryPage.tsx
    │   │       ├── useMyLoanHistory.ts
  ```

## 데이터 MOCKING 이 필요한 경우
- Mock Data 는 public/mock/~ 경로에 json 형식으로 데이터를 생성한다 (파일명 : {subject}.json)
- Mock/API 스위치:  Mock 데이터는 .json 파일로 만들어두고,  경로는 {프로젝트}/public/mock 밑에 apiPath 붙인다
  - DEMO 모드에서만 Mock데이터를 사용한다. DEV 모드에서는 별도의 백엔드 서버에서 API 를 호출해 사용한다
    ```
    예시 : {VITE_API_BASE_URL}/book/sku
      ㄴ DEMO : (MOCK 모드) VITE_API_BASE_URL={프론트엔드SELF}/public/mock
      ㄴ DEV : (백엔드 존재) VITE_API_BASE_URL=http://localhost:8080
    ```
  - 모킹여부와 관계없이 코드는 변하지 않는다. DEV(API사용) <--> DEMO(Mock) 간에는 VITE_API_BASE_URL 로만 제어된다.

### 타입스크립트 코드 및 스타일 가이드
- 기존 데이터 변경 최소화
- 코드 및 파일 스타일은 ~Page(리액트 페이지), use~(훅)
- 서브컴포넌트는 임의로 만들지 말것
- any타입 최대한 지향하고 TypeScript 정석적인 방법으로 개발할것
- 정석적인 방법으로 개발하고 Work-around(야매) 방법으로 진행하지 말것
- TypeScript의 타입 전용 임포트(Type-Only Imports)/ 인라인 타입 전용 임포트(Inline Type-Only Imports) 문법 사용할것
- cn 은 여기에 있음 : import {cn} from "@/core/utils.ts";
- React Props 정의 시 추가 속성이 없다면 interface 대신 type 별칭(Alias)을 사용하고, 속성 확장이 있을 때만 interface를 사용하는 TypeScript 정석 패턴을 적용할것
- React.FormEvent<>는 사용하지 않는다 
- 함수 호출 시에는 삼항 연산자 대신 명시적인 if/else 문을 사용하여 no-unused-expressions 에러가 없는 정석적인 코드를 작성해야 한다
- 유니온 타입을 정의할 때 리터럴을 직접 나열하지 마세요. 대신 런타임에 사용할 as const 배열을 먼저 선언하고, (typeof ARRAY)[number] 문법을 통해 타입을 추출하는 'Derived Union Type' 패턴을 적용하여 타입과 데이터의 동기화를 보장해줘.
  - DRY (Don't Repeat Yourself) 원칙 준수 
  - Hard-coded 방식: 카테고리가 추가되면 type 정의도 고치고, Select 박스용 array도 고쳐야 합니다. (두 번 일하기)
  - Derived 방식: RESOURCE_CATEGORIES 배열에 항목만 추가하면 타입은 알아서 따라옵니다. (한 번만 일하기)
  - 런타임과 컴파일 타임의 완벽한 동기화 : 리액트에서는 UI 렌더링을 위해 실제 **배열(값)**이 필요합니다. 타입을 배열에서 추출하면, UI에 뿌려지는 값과 타입스크립트가 검사하는 값이 절대로 틀어질 일이 없습니다.
  - 타입 추론의 우수성 : Object.keys()나 Object.values()를 쓸 때 발생하는 번거로운 타입 캐스팅(as ResourceCategory[])이 필요 없습니다. 배열 자체가 이미 가장 좁은(narrow) 타입인 리터럴들의 모음이기 때문입니다.
- 상태관리 라이브러리(zustand 등..) 은 사용하지 않아야 한다
- 런타임에 데이터/변수 등에 의한 에러를 방어할 수 있는 로직 
- 이외 불명확하거나, 언급되지 않은 부분은 [Google TypeScript Style Guide](https://google.github.io/styleguide/tsguide.html) 지침에 따라야 합니다
  - 정석적인 방법으로 개발하며, Best Practice 방법으로 널리 인정받는 방향으로 개발되어야만 합니다
  - 이미 구현된 코드 베이스야 코드베이스 존중해서 기능만 추가할 수 있도록 코드를 추가해야 합니다

### package.json 내용 
- 아래의 의존성 이외에 추가적인 불필요한 의존성 추가는 최대한 피해야 합니다
```
 "dependencies": {
    "@radix-ui/react-label": "^2.1.8",
    "@radix-ui/react-popover": "^1.1.15",
    "@radix-ui/react-radio-group": "^1.3.8",
    "@radix-ui/react-select": "^2.2.6",
    "@radix-ui/react-slot": "^1.2.4",
    "axios": "^1.13.5",
    "class-variance-authority": "^0.7.1",
    "lucide-react": "^0.563.0",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "react-router-dom": "^7.13.0",
```


---

## 🎨 UI 컴포넌트 사용


### Hook 패턴
```
Page Component
    ↓ import
  useHook
    ↓ useEffect
  apiClient.get()
    ↓ response
  setState
    ↓ render
Page Component (updated)
```

- [x] 모든 페이지에서 이 패턴 준수
- [x] useState로 로컬 상태 관리
- [x] useEffect로 데이터 fetch
- [x] 로딩 상태 처리
- [x] 에러 처리 (console.error)

### API 호출 흐름
```
User Action
    ↓
Component Handler
    ↓
Hook Function (create, update, delete)
    ↓
apiClient (Axios)
    ↓ interceptor
Add Auth Token
    ↓
Backend API (or Mock)
    ↓
Response
    ↓
Update State
    ↓
Re-render
```

---
